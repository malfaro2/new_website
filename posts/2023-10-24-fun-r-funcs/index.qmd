---
title: "Three fun R functions"
description: "All the cool kids were jumping off the bridge!"
author:
  - name: Mike Mahoney
    url: {}
date: "2023-10-24"
categories: [R, Tutorials]
image: banner.jpg
format: 
  html:
    toc: true
engine: knitr
---

Inspired by [Maëlle](https://masalmon.eu/2023/10/20/three-neat-functions/) who was inspired by [Yihui](https://yihui.org/en/2023/10/three-functions/) who was inspired by [Maëlle](https://masalmon.eu/2023/09/29/three-functions/)(who has [a whole](https://masalmon.eu/2023/08/31/three-shorten/) [series](https://masalmon.eu/2023/06/06/basic-patterns/) [about](https://masalmon.eu/2023/08/30/three-r-functions/) [this](https://masalmon.eu/2023/07/24/basic-notions/)), I wanted to share three useful base R functions that I think maybe don't get enough love. And inspired by [Maëlle again](https://masalmon.eu/2023/10/20/three-neat-functions/), my list here is actually four functions.

## `sweep()`

If you ever need to do math with matrices, then `sweep()` is going to be your best friend. Say for instance we want to center and scale each column in a matrix. This is a pretty straightforward operation -- we need to calculate the mean and standard deviations for each column, subtract the column mean from each observation, and then divide those by the corresponding standard deviation.

We can use `apply` to get our means and standard deviations:

```{r}
# Generate some fake data in a 10x10 matrix:
x <- matrix(data = rnorm(100), nrow = 10)
# Calculate one mean and sd for each column of our matrix:
col_means <- apply(x, 2, mean)
col_sds <- apply(x, 2, sd)
```

The subtraction and division are a bit less straightforward. R's base math operators will attempt to do element-wise operations, treating our vector as a one-column array and replicating as needed. That's not what we want:

```{r}
all.equal(
  (x - col_means) / col_sds,
  scale(x)
)
```

We could replicate our vector ourself, in order to take advantage of these element-wise operations:

```{r}
all.equal(
  ((x - matrix(rep(col_means, 10), 10, byrow = TRUE)) / 
    matrix(rep(col_sds, 10), 10, byrow = TRUE)) |> as.vector(),
  scale(x) |> as.vector()
)
```

But that's silly, especially if we were working with more observations.

Better instead is to use `sweep()` to perform some operation between each element of our vector and each column of the matrix:

```{r}
# Take every value in our matrix, and subtract its corresponding column mean:
centered <- sweep(
  x = x, 
  MARGIN = 2, # just like in apply()
  STATS = col_means, 
  FUN = "-" # "-" is the default argument -- we don't NEED to provide it here
)
```

And we can similarly use `sweep()` to divide each column by its corresponding standard deviation, finishing up our centering and scaling:

```{r}
# Divide each value by its corresponding column sd:
centered_and_scaled <- sweep(centered, 2, col_sds, "/")

# Works out identically to the built-in scale function:
all.equal(
  as.vector(centered_and_scaled),
  as.vector(scale(x))
)
```

This is the main way I use `sweep()`, but there's no requirement you use it for math -- it works just as well with non-mathematical functions or non-numeric matrices:

```{r}
letter_mat <- matrix(rep(letters[1:5], 5), 5)
letter_mat

sweep(letter_mat, 2, LETTERS[1:5], paste0)
```

## `reformulate()` and `DF2formula()`

The `reformulate()` function is a lifesaver if you're trying to write long or complicated formulas, or multiple formulas generated by some other logic in your code.

The function is pretty straightforward. If you're trying to make a formula `y ~ x + z`, provide your predictors as the first argument and your outcome as the second:

```{r}
reformulate(c("x", "z"), "y")
```

The nice thing is that `reformulate` accepts vectors as inputs, making it easy to construct a vector of predictors and automatically turn them into a formula:

```{r}
reformulate(letters, "outcome")

reformulate(names(Orange), "age")
```

And in particular, this is an excellent alternative to dropping a few columns in order to use `outcome ~ .` -- instead, you can use `setdiff()` to exclude those columns from your formula:

```{r}
outcome_variable <- "age"
reformulate(setdiff(names(Orange), outcome_variable), outcome_variable)
```

Relatedly, the function `DF2formula()` will automatically turn the column names from a data frame into a formula. The first column will become the outcome variable, and the rest will be used as predictors:

```{r}
DF2formula(Orange)
```

To change what column is used as the outcome variable, reorder the columns in your data frame:

```{r}
DF2formula(Orange[3:1])
```

## `str2lang()`

Shockingly enough, `str2lang()` function turns a string into a language object:

```{r}
growth_rate <- "circumference / age"
str2lang(growth_rate)
class(str2lang(growth_rate))
```

Wooooo!

I think that, to most people, this does not sound immediately useful.^[I think, to most people, this barely sounds like English.] But the idea that your code can turn plain text into code at runtime is pretty powerful, and some of the most R-esque nonsense that R has to offer.

For instance, we can use `eval()` to actually execute the call created by `str2lang()` in our global environment:

```{r}
eval(str2lang("2 + 2"))
```

And that string can do anything that regular R code can do -- assign variables, manage connections, any procedure that normal R code can do:

```{r}
eval(str2lang("x <- 3"))
x
```

We can also use this with `with()` or `local()` to execute our code inside of other environments. For instance, if we want to calculate our `growth_rate` from earlier, we can run that code with the `Orange` data frame:

```{r}
with(Orange, eval(str2lang(growth_rate)))
```

This can be a powerful way to "import" code from other sources, for instance if you have a CSV of equations you want to run against a data frame. You want to be careful when using this with untrusted inputs, of course -- if your input includes a call to `system()`, it might wind up wrecking your computer! 
